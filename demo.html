<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Horizontal Timeline — Scroll-to-Horizontal Section</title>
  <style>
    :root{
      --gap: 24px;
      --item-w: 360px;
      --accent: #2d4f2b;
      --muted: #f4f7f2;
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial,Helvetica,sans-serif;color:#222}
    main{min-height:200vh;padding:40px 20px;box-sizing:border-box;background:linear-gradient(180deg,#fff,#f7f9f6)}

    h1{margin:0 0 18px;font-size:28px;color:var(--accent)}
    p.lead{margin:0 0 24px;color:#444}

    /* TIMELINE SECTION */
    .timeline-section{
      position:relative;
      margin:48px 0;
      height:66vh; /* big area so user 'lands' here */
      max-height:720px;
      min-height:420px;
      display:flex;align-items:center;justify-content:center;
      background:linear-gradient(90deg, rgba(45,79,43,0.04), rgba(255,255,255,0.6));
      border-radius:14px;padding:30px;box-sizing:border-box;overflow:visible;
    }

    .timeline-container{
      width:100%;height:100%;overflow:hidden;position:relative;
    }

    .timeline-track{
      display:flex;align-items:stretch;gap:var(--gap);
      height:100%;overflow-x:auto;overflow-y:hidden;scroll-snap-type:x mandatory;scroll-behavior:smooth;
      padding:20px 40px;box-sizing:border-box;
    }

    /* Hide scrollbar in most browsers but keep for keyboard focus */
    .timeline-track::-webkit-scrollbar{height:10px}
    .timeline-track::-webkit-scrollbar-thumb{background:rgba(0,0,0,0.12);border-radius:10px}
    .timeline-track{ -ms-overflow-style: none; scrollbar-width: none; }
    .timeline-track::-webkit-scrollbar { display: none; }

    .step{
      flex:0 0 var(--item-w);background:white;border-radius:12px;padding:20px;box-sizing:border-box;
      box-shadow:0 6px 18px rgba(0,0,0,0.06);display:flex;flex-direction:column;justify-content:flex-start;scroll-snap-align:center;
    }

    .step h3{margin:0 0 8px;font-size:18px;color:var(--accent)}
    .step p{margin:0;color:#444;line-height:1.4}

    /* Edge message / indicators */
    .edge-indicator{position:absolute;top:18px;left:24px;font-weight:600;color:#6a6a6a}
    .edge-indicator.right{left:auto;right:24px}

    .hint{position:absolute;bottom:18px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.06);padding:8px 12px;border-radius:999px;font-size:13px}

    /* responsive */
    @media (max-width:900px){
      :root{--item-w:270px}
      .timeline-section{height:56vh;min-height:360px}
    }
    @media (max-width:600px){
      :root{--item-w:86vw}
      .timeline-section{height:68vh;min-height:420px}
      .timeline-track{padding:16px}
      .step{padding:18px}
      h1{font-size:22px}
    }

    /* small polish for keyboard focus */
    .step:focus{outline:3px solid rgba(45,79,43,0.12)}
  </style>
</head>
<body>
  <main>
    <h1>How It Works — Timeline</h1>
    <p class="lead">Scroll into the timeline section. On desktop, mouse wheel (or trackpad) will move horizontally until the timeline ends, then normal page scroll resumes. On mobile, vertical swipes while inside the section are converted to horizontal movement; reversing works the same.</p>

    <section style="height:60vh;background:#fff;border-radius:8px;padding:18px;box-shadow:0 6px 18px rgba(0,0,0,0.04);">
      <strong>Intro content</strong>
      <p>Some page content above the timeline so you can scroll into the timeline section naturally.</p>
    </section>

    <!-- TIMELINE SECTION -->
    <section class="timeline-section" id="timelineSection">
      <div class="timeline-container">
        <div class="edge-indicator left">Start</div>
        <div class="edge-indicator right">End</div>

        <div class="timeline-track" id="timelineTrack" tabindex="0" aria-label="Horizontal timeline">
          <!-- Steps: example six steps matching user's content -->
          <article class="step">
            <h3>STEP 1 — Select Your Meal Plan</h3>
            <p>Browse flexible meal options — Veg, Jain, Healthy, or Customized. Choose daily, weekly, or monthly subscriptions.</p>
          </article>
          <article class="step">
            <h3>STEP 2 — Place Your Order</h3>
            <p>Order in a few clicks. Sign up and choose delivery schedule for lunch, dinner, or both. No calls — no hassle.</p>
          </article>
          <article class="step">
            <h3>STEP 3 — Fresh Meals, Cooked Daily</h3>
            <p>Our chefs prepare fresh meals each morning, balanced and preservative-free — just like home.</p>
          </article>
          <article class="step">
            <h3>STEP 4 — On-Time Delivery, Every Time</h3>
            <p>We deliver hot tiffins across Mumbai. Smart routing ensures meals arrive on time — home, office, or college.</p>
          </article>
          <article class="step">
            <h3>STEP 5 — Eat Well, Live Better</h3>
            <p>Enjoy a rotating menu that never gets boring. Unbox your meal and enjoy that ghar ka khana feeling.</p>
          </article>
          <article class="step">
            <h3>STEP 6 — Pause, Switch, or Cancel Anytime</h3>
            <p>Plans change — pause, reschedule, or change your meal type via dashboard or WhatsApp support.</p>
          </article>
        </div>

        <div class="hint" id="scrollHint">Scroll →</div>
      </div>
    </section>

    <section style="height:60vh;background:#fff;border-radius:8px;padding:18px;box-shadow:0 6px 18px rgba(0,0,0,0.04);margin-top:28px;">
      <strong>More page content</strong>
      <p>After the timeline ends, the page continues to scroll normally downward.</p>
    </section>

  </main>

  <script>
    (function(){
      const track = document.getElementById('timelineTrack');
      const section = document.getElementById('timelineSection');
      const hint = document.getElementById('scrollHint');

      // Utility to tell whether element is in viewport (mostly vertical center)
      function isSectionMostlyVisible(){
        const rect = section.getBoundingClientRect();
        return (rect.top < window.innerHeight*0.6 && rect.bottom > window.innerHeight*0.2);
      }

      // Update hint (start / end / middle)
      function updateHint(){
        const max = track.scrollWidth - track.clientWidth;
        if (track.scrollLeft <= 4) hint.textContent = 'Scroll →';
        else if (track.scrollLeft >= max - 4) hint.textContent = 'Done — Scroll Down';
        else hint.textContent = 'Drag / Wheel to scroll';
      }
      updateHint();

      // --- Desktop wheel -> horizontal mapping (but allow normal page scroll when at ends) ---
      track.addEventListener('wheel', function(e){
        // Only when the timeline section is mostly visible (so user intended to interact with it)
        if (!isSectionMostlyVisible()) return; // allow page scroll

        const deltaY = e.deltaY;
        const atStart = track.scrollLeft <= 0;
        const maxScrollLeft = track.scrollWidth - track.clientWidth;
        const atEnd = track.scrollLeft >= maxScrollLeft - 1;

        // If user is trying to scroll beyond ends, let the page scroll normally
        if ((atStart && deltaY < 0) || (atEnd && deltaY > 0)) {
          // let default so page scrolls
          return;
        }

        // otherwise consume the wheel and move horizontally
        e.preventDefault();
        // Use scrollBy for smooth feel (no heavy animation)
        track.scrollBy({ left: deltaY, behavior: 'auto' });
        // update hint
        requestAnimationFrame(updateHint);
      }, { passive: false });

      // --- Touch handling for mobile: map vertical swipes to horizontal scroll ---
      let touchStartY = 0;
      let touchStartX = 0;
      let lastTouchTime = 0;

      track.addEventListener('touchstart', function(e){
        if (e.touches.length === 1){
          touchStartY = e.touches[0].clientY;
          touchStartX = e.touches[0].clientX;
          lastTouchTime = Date.now();
        }
      }, {passive:true});

      track.addEventListener('touchmove', function(e){
        if (e.touches.length !== 1) return;
        // If section not visible enough, don't hijack (allow page)
        if (!isSectionMostlyVisible()) return;

        const y = e.touches[0].clientY;
        const x = e.touches[0].clientX;
        const dy = touchStartY - y; // positive when swiping up
        const dx = touchStartX - x;

        // Heuristic: if vertical movement is more significant than horizontal, map vertical to horizontal
        if (Math.abs(dy) > Math.abs(dx) * 0.6) {
          // check bounds similar to wheel logic
          const atStart = track.scrollLeft <= 0;
          const maxScrollLeft = track.scrollWidth - track.clientWidth;
          const atEnd = track.scrollLeft >= maxScrollLeft - 1;

          if ((atStart && dy < 0) || (atEnd && dy > 0)) {
            // reaching beyond end/start -> allow normal page scrolling
            return; // passive so default page scroll occurs
          }

          // otherwise prevent default vertical scrolling and move horizontally by dy
          e.preventDefault();
          track.scrollBy({ left: dy, behavior: 'auto' });
          touchStartY = y; // update so movement is continuous
          touchStartX = x;
          requestAnimationFrame(updateHint);
        }
      }, { passive: false });

      // Allow keyboard arrow navigation inside the track
      track.addEventListener('keydown', function(e){
        if (e.key === 'ArrowRight') { track.scrollBy({left: 200, behavior:'smooth'}); e.preventDefault(); }
        if (e.key === 'ArrowLeft') { track.scrollBy({left: -200, behavior:'smooth'}); e.preventDefault(); }
      });

      // Update hint when user scrolls the track using other means
      track.addEventListener('scroll', function(){ requestAnimationFrame(updateHint); });

      // Accessibility: if user tabs into the track, hint becomes visible
      track.addEventListener('focus', ()=> hint.style.opacity = 1);
      track.addEventListener('blur', ()=> hint.style.opacity = 0.95);

      // Optional: when user reaches end via programmatic or touch, give a tiny nudge so page scroll continues
      // (not required but improves UX)
      let lastKnown = 0;
      setInterval(()=>{
        const max = track.scrollWidth - track.clientWidth;
        if (Math.abs(track.scrollLeft - lastKnown) > 1) { lastKnown = track.scrollLeft; updateHint(); }
      }, 300);

      // If user resizes window, ensure hint updates
      window.addEventListener('resize', updateHint);

      // Simple example for reversing: when the timeline is not in view, natural page scrolling applies.
      // The two-way mapping (vertical -> horizontal and horizontal -> vertical resume at ends) is handled above.

    })();
  </script>
</body>
</html>
